/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => CompletrPlugin
});
var import_obsidian4 = __toModule(require("obsidian"));

// src/snippet_manager.ts
var import_view2 = __toModule(require("@codemirror/view"));

// src/editor_helpers.ts
function posFromIndex(doc, offset) {
  let line = doc.lineAt(offset);
  return { line: line.number - 1, ch: offset - line.from };
}
function indexFromPos(doc, pos) {
  const ch = pos.ch;
  const line = doc.line(pos.line + 1);
  return Math.min(line.from + Math.max(0, ch), line.to);
}
function editorToCodeMirrorState(editor) {
  return editor.cm.state;
}
function editorToCodeMirrorView(editor) {
  return editor.cm;
}
function matchWordBackwards(editor, cursor, charValidator, maxLookBackDistance = 50) {
  let query = "", separatorChar = null;
  let lookBackEnd = Math.max(0, cursor.ch - maxLookBackDistance);
  for (let i = cursor.ch - 1; i >= lookBackEnd; i--) {
    const prevChar = editor.getRange(__spreadProps(__spreadValues({}, cursor), { ch: i }), __spreadProps(__spreadValues({}, cursor), { ch: i + 1 }));
    if (!charValidator(prevChar)) {
      separatorChar = prevChar;
      break;
    }
    query = prevChar + query;
  }
  return { query, separatorChar };
}
function isInFrontMatterBlock(editor, pos) {
  if (editor.getLine(0) !== "---" || editor.getLine(1) === "---" || pos.line === 0)
    return false;
  for (let i = 2; i < Math.max(30, editor.lastLine()); i++) {
    if (editor.getLine(i) === "---")
      return pos.line < i;
  }
  return false;
}
function isInLatexBlock(editor, pos) {
  var BlockType;
  (function(BlockType2) {
    BlockType2[BlockType2["NONE"] = 0] = "NONE";
    BlockType2[BlockType2["SINGLE"] = 1] = "SINGLE";
    BlockType2[BlockType2["DOUBLE"] = 2] = "DOUBLE";
  })(BlockType || (BlockType = {}));
  let blockStartingLine = 0;
  let currentBlockType = 0;
  for (let i = pos.line; i >= Math.max(0, pos.line - 1e3); i--) {
    const line = editor.getLine(i);
    for (let j = pos.line == i ? pos.ch - 1 : line.length - 1; j >= 0; j--) {
      if (line.charAt(j) !== "$")
        continue;
      let isDouble = j != 0 && line.charAt(j - 1) === "$";
      if (isDouble)
        j--;
      blockStartingLine = 0;
      if (currentBlockType === 1 && isDouble || currentBlockType === 2 && !isDouble) {
        return true;
      } else if (!isDouble && currentBlockType === 1) {
        currentBlockType = 0;
      } else if (isDouble && currentBlockType === 2) {
        currentBlockType = 0;
      } else {
        blockStartingLine = i;
        currentBlockType = isDouble ? 2 : 1;
      }
    }
    if (currentBlockType === 1)
      return true;
  }
  return currentBlockType !== 0;
}

// src/marker_state_field.ts
var import_state = __toModule(require("@codemirror/state"));
var import_view = __toModule(require("@codemirror/view"));
var addMark = import_state.StateEffect.define();
var clearMarks = import_state.StateEffect.define();
var removeMarkBySpecAttribute = import_state.StateEffect.define();
var markerStateField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(addMark))
        value = value.update({ add: [effect.value] });
      else if (effect.is(clearMarks))
        value = value.update({ filter: () => false });
      else if (effect.is(removeMarkBySpecAttribute))
        value = value.update({ filter: (from, to, ref) => ref.spec[effect.value.attribute] !== effect.value[effect.value.attribute] });
    }
    return value;
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});

// src/snippet_manager.ts
var COLORS = ["lightskyblue", "orange", "lime", "pink", "cornsilk", "magenta", "navajowhite"];
var PlaceholderReference = class {
  constructor(editor) {
    this.editor = editor;
  }
  get marker() {
    const state = editorToCodeMirrorState(this.editor);
    const iter = state.field(markerStateField).iter();
    while (iter.value) {
      if (iter.value.spec.reference === this) {
        return {
          from: iter.from,
          to: iter.to,
          value: iter.value
        };
      }
      iter.next();
    }
    return null;
  }
  removeFromEditor() {
    editorToCodeMirrorView(this.editor).dispatch({
      effects: removeMarkBySpecAttribute.of({ attribute: "reference", reference: this })
    });
  }
};
var SnippetManager = class {
  constructor() {
    this.currentPlaceholderReferences = [];
  }
  handleSnippet(value, start, editor) {
    let colorIndex = 0;
    for (; colorIndex < COLORS.length; colorIndex++) {
      if (!this.currentPlaceholderReferences.find((p) => p.marker.value.spec.attributes.class.endsWith(colorIndex + "")))
        break;
    }
    if (colorIndex === COLORS.length) {
      console.log("Completr: No colors left for snippet, using random color");
      colorIndex = Math.floor(Math.random() * COLORS.length);
    }
    const editorView = editorToCodeMirrorView(editor);
    const lines = value.split("\n");
    for (let lineIndex = lines.length - 1; lineIndex >= 0; lineIndex--) {
      const line = lines[lineIndex];
      for (let i = line.length - 1; i >= 0; i--) {
        const c = line.charAt(i);
        if (c !== "#" && c !== "~")
          continue;
        const lineBaseOffset = lineIndex === 0 ? start.ch : 0;
        if (c === "~") {
          const cursorPos = { line: start.line + lineIndex, ch: lineBaseOffset + i };
          editor.setCursor(cursorPos);
          editor.replaceRange("", cursorPos, __spreadProps(__spreadValues({}, cursorPos), { ch: cursorPos.ch + 1 }));
          continue;
        }
        const reference = new PlaceholderReference(editor);
        let mark = import_view2.Decoration.mark({
          inclusive: true,
          attributes: {
            style: "border-width: 1px 0 1px 0;border-style: solid;",
            class: "completr-suggestion-placeholder" + colorIndex
          },
          reference
        }).range(indexFromPos(editorView.state.doc, { line: start.line + lineIndex, ch: lineBaseOffset + i }), indexFromPos(editorView.state.doc, { line: start.line + lineIndex, ch: lineBaseOffset + i + 1 }));
        editorView.dispatch({ effects: addMark.of(mark) });
        this.currentPlaceholderReferences.unshift(reference);
      }
    }
    this.selectMarker(this.currentPlaceholderReferences[0]);
  }
  consumeAndGotoNextMarker(editor) {
    const oldPlaceholder = this.currentPlaceholderReferences.shift();
    const oldRange = SnippetManager.rangeFromPlaceholder(oldPlaceholder);
    oldPlaceholder.removeFromEditor();
    if (this.currentPlaceholderReferences.length === 0)
      return false;
    const placeholder = this.currentPlaceholderReferences[0];
    const newRange = SnippetManager.rangeFromPlaceholder(placeholder);
    if (newRange.from.ch <= oldRange.from.ch && newRange.to.ch >= oldRange.to.ch) {
      editor.setCursor(__spreadValues({}, newRange.to));
    } else {
      this.selectMarker(placeholder);
    }
    return true;
  }
  placeholderAtPos(pos) {
    for (let i = this.currentPlaceholderReferences.length - 1; i >= 0; i--) {
      const placeholder = this.currentPlaceholderReferences[i];
      const range = SnippetManager.rangeFromPlaceholder(placeholder);
      if (!range) {
        this.currentPlaceholderReferences.slice(i, 1);
        continue;
      }
      if (range.from.ch <= pos.ch && range.to.ch >= pos.ch)
        return placeholder;
    }
    return null;
  }
  selectMarker(reference) {
    if (!reference)
      return;
    const from = posFromIndex(editorToCodeMirrorState(reference.editor).doc, reference.marker.from);
    reference.editor.setSelection(from, __spreadProps(__spreadValues({}, from), { ch: from.ch + 1 }));
  }
  clearAllPlaceholders() {
    if (this.currentPlaceholderReferences.length === 0)
      return;
    const firstRef = this.currentPlaceholderReferences[0];
    const view = editorToCodeMirrorView(firstRef.editor);
    view.dispatch({
      effects: clearMarks.of(null)
    });
    this.currentPlaceholderReferences = [];
  }
  static rangeFromPlaceholder(reference) {
    const marker = reference.marker;
    if (!marker)
      return null;
    return {
      from: posFromIndex(editorToCodeMirrorState(reference.editor).doc, marker.from),
      to: posFromIndex(editorToCodeMirrorState(reference.editor).doc, marker.to)
    };
  }
  onunload() {
    this.clearAllPlaceholders();
  }
};

// src/provider/provider.ts
function getSuggestionDisplayName(suggestion) {
  return typeof suggestion === "string" ? suggestion : suggestion.displayName;
}
function getSuggestionReplacement(suggestion) {
  return typeof suggestion === "string" ? suggestion : suggestion.replacement;
}

// src/provider/latex_provider.ts
function substringUntil(str, delimiter) {
  let index = str.indexOf(delimiter);
  if (index === -1)
    return str;
  return str.substring(0, index);
}
var LatexSuggestionProvider = class {
  getSuggestions(context, settings) {
    if (!settings.latexProviderEnabled || !context.query)
      return [];
    let editor = context.editor;
    if (!isInLatexBlock(editor, context.start))
      return [];
    const isSeparatorBackslash = context.separatorChar === "\\";
    return LATEX_COMMANDS.filter((s) => getSuggestionDisplayName(s).contains(context.query)).map((s) => {
      const replacement = getSuggestionReplacement(s);
      const displayName = getSuggestionDisplayName(s);
      return {
        displayName,
        replacement: isSeparatorBackslash ? replacement.substring(1) : replacement,
        priority: displayName.indexOf(context.query)
      };
    }).sort((a, b) => {
      let val = a.priority - b.priority;
      if (val == 0)
        val = substringUntil(a.displayName, "{").length - substringUntil(b.displayName, "{").length;
      return val;
    });
  }
};
var Latex = new LatexSuggestionProvider();
function generateEnvironments(environments) {
  const result = [];
  for (let i = 0; i < environments.length; i++) {
    const environment = environments[i];
    if (environment.hasStarVersion) {
      environments.push(__spreadProps(__spreadValues({}, environment), { name: environment.name + "*", hasStarVersion: false }));
    }
    result.push({
      displayName: `\\begin{${environment.name}}...`,
      replacement: `\\begin{${environment.name}}${"{#}".repeat(environment.paramCount)}
${environment.paramCount < 1 ? "~\n" : ""}\\end{${environment.name}}`
    });
  }
  return result;
}
var LATEX_COMMANDS = [
  ...generateEnvironments([
    { name: "align", paramCount: 0, hasStarVersion: true },
    { name: "alignat", paramCount: 1, hasStarVersion: true },
    { name: "aligned", paramCount: 0, hasStarVersion: false },
    { name: "alignedat", paramCount: 1, hasStarVersion: false },
    { name: "array", paramCount: 1, hasStarVersion: false },
    { name: "bmatrix", paramCount: 0, hasStarVersion: true },
    { name: "Bmatrix", paramCount: 0, hasStarVersion: true },
    { name: "bsmallmatrix", paramCount: 0, hasStarVersion: true },
    { name: "Bsmallmatrix", paramCount: 0, hasStarVersion: true },
    { name: "cases", paramCount: 0, hasStarVersion: true },
    { name: "crampedsubarray", paramCount: 1, hasStarVersion: false },
    { name: "dcases", paramCount: 0, hasStarVersion: true },
    { name: "drcases", paramCount: 0, hasStarVersion: true },
    { name: "empheq", paramCount: 2, hasStarVersion: false },
    { name: "eqnarray", paramCount: 0, hasStarVersion: true },
    { name: "equation", paramCount: 0, hasStarVersion: true },
    { name: "flalign", paramCount: 0, hasStarVersion: true },
    { name: "gather", paramCount: 0, hasStarVersion: true },
    { name: "gathered", paramCount: 0, hasStarVersion: false },
    { name: "lgathered", paramCount: 0, hasStarVersion: false },
    { name: "matrix", paramCount: 0, hasStarVersion: true },
    { name: "multiline", paramCount: 0, hasStarVersion: true },
    { name: "multilined", paramCount: 0, hasStarVersion: false },
    { name: "numcases", paramCount: 1, hasStarVersion: false },
    { name: "pmatrix", paramCount: 0, hasStarVersion: true },
    { name: "prooftree", paramCount: 0, hasStarVersion: false },
    { name: "psmallmatrix", paramCount: 0, hasStarVersion: true },
    { name: "rcases", paramCount: 0, hasStarVersion: true },
    { name: "rgathered", paramCount: 0, hasStarVersion: false },
    { name: "smallmatrix", paramCount: 0, hasStarVersion: true },
    { name: "split", paramCount: 0, hasStarVersion: false },
    { name: "spreadlines", paramCount: 1, hasStarVersion: false },
    { name: "subarray", paramCount: 1, hasStarVersion: false },
    { name: "subnumcases", paramCount: 1, hasStarVersion: false },
    { name: "vmatrix", paramCount: 0, hasStarVersion: true },
    { name: "Vmatrix", paramCount: 0, hasStarVersion: true },
    { name: "vsmallmatrix", paramCount: 0, hasStarVersion: true },
    { name: "Vsmallmatrix", paramCount: 0, hasStarVersion: true },
    { name: "xalignat", paramCount: 1, hasStarVersion: true },
    { name: "xxalignat", paramCount: 1, hasStarVersion: false }
  ]),
  "\\above{#}{#}",
  "\\verb|#|",
  "\\left\\",
  "\\right\\",
  "\\acute{#}",
  "\\aleph",
  "\\alpha",
  "\\amalg",
  "\\And",
  "\\angle",
  "\\approx",
  "\\approxeq",
  "\\arccos",
  "\\arcsin",
  "\\arctan",
  "\\arg",
  "\\array{#}",
  "\\arrowvert",
  "\\Arrowvert",
  "\\ast",
  "\\asymp",
  "\\atop",
  "\\backepsilon",
  "\\backprime",
  "\\backsim",
  "\\backsimeq",
  "\\backslash",
  "\\bar{#}",
  "\\barwedge",
  "\\Bbb{#}",
  "\\Bbbk",
  "\\bbFont",
  "\\bbox{#}",
  "\\bcancel{#}",
  "\\because",
  "\\beta",
  "\\beth",
  "\\between",
  "\\bf",
  "\\bigcap",
  "\\bigcirc",
  "\\bigcup",
  "\\bigodot",
  "\\bigoplus",
  "\\bigotimes",
  "\\bigsqcup",
  "\\bigstar",
  "\\bigtimes",
  "\\bigtriangledown",
  "\\bigtriangleup",
  "\\biguplus",
  "\\bigvee",
  "\\bigwedge",
  "\\binom{#}{#}",
  "\\blacklozenge",
  "\\blacksquare",
  "\\blacktriangle",
  "\\blacktriangledown",
  "\\blacktriangleleft",
  "\\blacktriangleright",
  "\\bmod",
  "\\boldsymbol{#}",
  "\\bot",
  "\\bowtie",
  "\\Box",
  "\\boxdot",
  "\\boxed{#}",
  "\\boxminus",
  "\\boxplus",
  "\\boxtimes",
  "\\bra{#}",
  "\\Bra{#}",
  "\\brace",
  "\\bracevert",
  "\\brack",
  "\\braket{#}",
  "\\Braket{#}",
  "\\breve{#}",
  "\\bullet",
  "\\bumpeq",
  "\\Bumpeq",
  "\\cal",
  "\\cancel{#}",
  "\\cancelto{#}{#}",
  "\\cap",
  "\\Cap",
  "\\cases{#}",
  "\\cdot",
  "\\cdotp",
  "\\cdots",
  "\\celsius",
  "\\centercolon",
  "\\centerdot",
  "\\centernot{#}",
  "\\centerOver{#}{#}",
  "\\cfrac{#}{#}",
  "\\check{#}",
  "\\checkmark",
  "\\chi",
  "\\choose",
  "\\circ",
  "\\circeq",
  "\\circlearrowleft",
  "\\circlearrowright",
  "\\circledast",
  "\\circledcirc",
  "\\circleddash",
  "\\circledR",
  "\\circledS",
  "\\clap{#}",
  "\\class{#}{#}",
  "\\clubsuit",
  "\\colon",
  "\\colonapprox",
  "\\Colonapprox",
  "\\coloneq",
  "\\Coloneq",
  "\\coloneqq",
  "\\Coloneqq",
  "\\colonsim",
  "\\Colonsim",
  "\\color{#}",
  "\\colorbox{#}{#}",
  "\\complement",
  "\\cong",
  "\\coprod",
  "\\cos",
  "\\cosh",
  "\\cot",
  "\\coth",
  "\\cramped{#}",
  "\\crampedclap{#}",
  "\\crampedllap{#}",
  "\\crampedrlap{#}",
  "\\crampedsubstack{#}",
  "\\csc",
  "\\cssId{#}{#}",
  "\\cup",
  "\\Cup",
  "\\curlyeqprec",
  "\\curlyeqsucc",
  "\\curlyvee",
  "\\curlywedge",
  "\\curvearrowleft",
  "\\curvearrowright",
  "\\dagger",
  "\\daleth",
  "\\dashleftarrow",
  "\\dashrightarrow",
  "\\dashv",
  "\\dbinom{#}{#}",
  "\\dblcolon",
  "\\ddagger",
  "\\ddddot{#}",
  "\\dddot{#}",
  "\\ddot{#}",
  "\\ddots",
  "\\DeclareMathOperator{#}{#}",
  "\\DeclarePairedDelimiters{#}{#}{#}",
  "\\DeclarePairedDelimitersX{#}{#}{#}{#}",
  "\\DeclarePairedDelimitersXPP{#}{#}{#}{#}{#}{#}",
  "\\deg",
  "\\degree",
  "\\delta",
  "\\Delta",
  "\\det",
  "\\dfrac{#}{#}",
  "\\diagdown",
  "\\diagup",
  "\\diamond",
  "\\Diamond",
  "\\diamondsuit",
  "\\digamma",
  "\\dim",
  "\\displaylines{#}",
  "\\displaystyle",
  "\\div",
  "\\divideontimes",
  "\\divsymbol",
  "\\dot{#}",
  "\\doteq",
  "\\Doteq",
  "\\doteqdot",
  "\\dotplus",
  "\\dots",
  "\\dotsb",
  "\\dotsc",
  "\\dotsi",
  "\\dotsm",
  "\\dotso",
  "\\doublebarwedge",
  "\\doublecap",
  "\\doublecup",
  "\\downarrow",
  "\\Downarrow",
  "\\downdownarrows",
  "\\downharpoonleft",
  "\\downharpoonright",
  "\\ell",
  "\\empheqbiglangle",
  "\\empheqbiglbrace",
  "\\empheqbiglbrack",
  "\\empheqbiglceil",
  "\\empheqbiglfloor",
  "\\empheqbiglparen",
  "\\empheqbiglvert",
  "\\empheqbiglVert",
  "\\empheqbigrangle",
  "\\empheqbigrbrace",
  "\\empheqbigrbrack",
  "\\empheqbigrceil",
  "\\empheqbigrfloor",
  "\\empheqbigrparen",
  "\\empheqbigrvert",
  "\\empheqbigrVert",
  "\\empheqlangle",
  "\\empheqlbrace",
  "\\empheqlbrack",
  "\\empheqlceil",
  "\\empheqlfloor",
  "\\empheqlparen",
  "\\empheqlvert",
  "\\empheqlVert",
  "\\empheqrangle",
  "\\empheqrbrace",
  "\\empheqrbrack",
  "\\empheqrceil",
  "\\empheqrfloor",
  "\\empheqrparen",
  "\\empheqrvert",
  "\\empheqrVert",
  "\\emptyset",
  "\\enclose{#}{#}",
  "\\enspace",
  "\\epsilon",
  "\\eqalign{#}",
  "\\eqalignno{#}",
  "\\eqcirc",
  "\\eqcolon",
  "\\Eqcolon",
  "\\eqqcolon",
  "\\Eqqcolon",
  "\\eqref{#}",
  "\\eqsim",
  "\\eqslantgtr",
  "\\eqslantless",
  "\\equiv",
  "\\eta",
  "\\eth",
  "\\exists",
  "\\exp",
  "\\fallingdotseq",
  "\\fbox{#}",
  "\\fCenter",
  "\\fcolorbox{#}{#}{#}",
  "\\Finv",
  "\\flat",
  "\\forall",
  "\\frac{#}{#}",
  "\\frak",
  "\\framebox{#}",
  "\\frown",
  "\\Game",
  "\\gamma",
  "\\Gamma",
  "\\gcd",
  "\\ge",
  "\\geq",
  "\\geqq",
  "\\geqslant",
  "\\gets",
  "\\gg",
  "\\ggg",
  "\\gggtr",
  "\\gimel",
  "\\gnapprox",
  "\\gneq",
  "\\gneqq",
  "\\gnsim",
  "\\grave{#}",
  "\\gt",
  "\\gtrapprox",
  "\\gtrdot",
  "\\gtreqless",
  "\\gtreqqless",
  "\\gtrless",
  "\\gtrsim",
  "\\gvertneqq",
  "\\hat{#}",
  "\\hbar",
  "\\hbox{#}",
  "\\heartsuit",
  "\\hline",
  "\\hom",
  "\\hookleftarrow",
  "\\hookrightarrow",
  "\\hphantom{#}",
  "\\href{#}{#}",
  "\\hslash",
  "\\huge",
  "\\Huge",
  "\\idotsint",
  "\\iff",
  "\\iiiint",
  "\\iiint",
  "\\iint",
  "\\Im",
  "\\imath",
  "\\impliedby",
  "\\implies",
  "\\in",
  "\\inf",
  "\\infty",
  "\\injlim",
  "\\int",
  "\\int^{#}_{#}",
  "\\intercal",
  "\\intop",
  "\\iota",
  "\\it",
  "\\jmath",
  "\\Join",
  "\\kappa",
  "\\ker",
  "\\ket{#}",
  "\\Ket{#}",
  "\\ketbra{#}{#}",
  "\\Ketbra{#}{#}",
  "\\label{#}",
  "\\lambda",
  "\\Lambda",
  "\\land",
  "\\langle",
  "\\large",
  "\\Large",
  "\\LARGE",
  "\\LaTeX",
  "\\lbrace",
  "\\lbrack",
  "\\lceil",
  "\\ldots",
  "\\ldotp",
  "\\le",
  "\\leadsto",
  "\\Leftarrow",
  "\\leftarrow",
  "\\leftarrowtail",
  "\\leftharpoondown",
  "\\leftharpoonup",
  "\\leftleftarrows",
  "\\Leftrightarrow",
  "\\leftrightarrow",
  "\\leftrightarrows",
  "\\leftrightharpoons",
  "\\leftrightsquigarrow",
  "\\leftthreetimes",
  "\\leq",
  "\\leqalignno{#}",
  "\\leqq",
  "\\leqslant",
  "\\lessapprox",
  "\\lessdot",
  "\\lesseqgtr",
  "\\lesseqqgtr",
  "\\lessgtr",
  "\\lesssim",
  "\\lfloor",
  "\\lg",
  "\\lgroup",
  "\\lhd",
  "\\lim",
  "\\liminf",
  "\\limsup",
  "\\ll",
  "\\llap{#}",
  "\\llcorner",
  "\\Lleftarrow",
  "\\lll",
  "\\llless",
  "\\lmoustache",
  "\\ln",
  "\\lnapprox",
  "\\lneq",
  "\\lneqq",
  "\\lnot",
  "\\lnsim",
  "\\log",
  "\\longleftarrow",
  "\\Longleftarrow",
  "\\Longleftrightarrow",
  "\\longleftrightarrow",
  "\\longleftrightarrows",
  "\\longLeftrightharpoons",
  "\\longmapsto",
  "\\longrightarrow",
  "\\Longrightarrow",
  "\\longrightleftharpoons",
  "\\longRightleftharpoons",
  "\\looparrowleft",
  "\\looparrowright",
  "\\lor",
  "\\lozenge",
  "\\lparen",
  "\\lrcorner",
  "\\Lsh",
  "\\lt",
  "\\ltimes",
  "\\lvert",
  "\\lVert",
  "\\lvertneqq",
  "\\maltese",
  "\\mapsto",
  "\\mathbb{#}",
  "\\mathbb{R}",
  "\\mathbb{N}",
  "\\mathbb{C}",
  "\\mathbb{Z}",
  "\\mathbb{Q}",
  "\\mathbf{#}",
  "\\mathbfcal{#}",
  "\\mathbffrak{#}",
  "\\mathbfit{#}",
  "\\mathbfscr{#}",
  "\\mathbfsf{#}",
  "\\mathbfsfit{#}",
  "\\mathbfsfup{#}",
  "\\mathbfup{#}",
  "\\mathbin{#}",
  "\\mathcal{#}",
  "\\mathchoice{#}{#}{#}{#}",
  "\\mathclap{#}",
  "\\mathclose{#}",
  "\\mathfrak{#}",
  "\\mathinner{#}",
  "\\mathit{#}",
  "\\mathllap{#}",
  "\\mathmakebox{#}",
  "\\mathmbox{#}",
  "\\mathnormal{#}",
  "\\mathop{#}",
  "\\mathopen{#}",
  "\\mathord{#}",
  "\\mathpunct{#}",
  "\\mathrel{#}",
  "\\mathring{#}",
  "\\mathrlap{#}",
  "\\mathrm{#}",
  "\\mathscr{#}",
  "\\mathsf{#}",
  "\\mathsfit{#}",
  "\\mathsfup{#}",
  "\\mathstrut",
  "\\mathtip{#}{#}",
  "\\mathtt{#}",
  "\\mathup{#}",
  "\\max",
  "\\mbox{#}",
  "\\measuredangle",
  "\\mho",
  "\\micro",
  "\\mid",
  "\\min",
  "\\mit",
  "\\mod{#}",
  "\\models",
  "\\mp",
  "\\MTThinColon",
  "\\mu",
  "\\multimap",
  "\\nabla",
  "\\natural",
  "\\ncong",
  "\\ndownarrow",
  "\\ne",
  "\\nearrow",
  "\\neg",
  "\\negmedspace",
  "\\negthickspace",
  "\\negthinspace",
  "\\neq",
  "\\newcommand{#}{#}",
  "\\newenvironment{#}{#}{#}",
  "\\newline",
  "\\newtagform{#}{#}{#}",
  "\\nexists",
  "\\ngeq",
  "\\ngeqq",
  "\\ngeqslant",
  "\\ngtr",
  "\\ni",
  "\\nleftarrow",
  "\\nLeftarrow",
  "\\nleftrightarrow",
  "\\nLeftrightarrow",
  "\\nleq",
  "\\nleqq",
  "\\nleqslant",
  "\\nless",
  "\\nmid",
  "\\nobreakspace",
  "\\nonscript",
  "\\nonumber",
  "\\normalsize",
  "\\not",
  "\\notag",
  "\\notChar",
  "\\notin",
  "\\nparallel",
  "\\nprec",
  "\\npreceq",
  "\\nrightarrow",
  "\\nRightarrow",
  "\\nshortmid",
  "\\nshortparallel",
  "\\nsim",
  "\\nsubseteq",
  "\\nsubseteqq",
  "\\nsucc",
  "\\nsucceq",
  "\\nsupseteq",
  "\\nsupseteqq",
  "\\ntriangleleft",
  "\\ntrianglelefteq",
  "\\ntriangleright",
  "\\ntrianglerighteq",
  "\\nu",
  "\\nuparrow",
  "\\nvdash",
  "\\nvDash",
  "\\nVdash",
  "\\nVDash",
  "\\nwarrow",
  "\\odot",
  "\\ohm",
  "\\oint",
  "\\oldstyle",
  "\\omega",
  "\\Omega",
  "\\omicron",
  "\\ominus",
  "\\operatorname{#}",
  "\\oplus",
  "\\ordinarycolon",
  "\\oslash",
  "\\otimes",
  "\\over",
  "\\overbrace{#}",
  "\\overbracket{#}",
  "\\overleftarrow{#}",
  "\\overleftrightarrow{#}",
  "\\overline{#}",
  "\\overparen{#}",
  "\\overrightarrow{#}",
  "\\overset{#}{#}",
  "\\overunderset{#}{#}{#}",
  "\\owns",
  "\\parallel",
  "\\partial",
  "\\perp",
  "\\perthousand",
  "\\phantom{#}",
  "\\phi",
  "\\Phi",
  "\\pi",
  "\\Pi",
  "\\pitchfork",
  "\\pm",
  "\\pmb{#}",
  "\\pmod{#}",
  "\\pod{#}",
  "\\Pr",
  "\\prec",
  "\\precapprox",
  "\\preccurlyeq",
  "\\preceq",
  "\\precnapprox",
  "\\precneqq",
  "\\precnsim",
  "\\precsim",
  "\\prescript{#}{#}{#}",
  "\\prime",
  "\\prod",
  "\\prod^{#}_{#}",
  "\\projlim",
  "\\propto",
  "\\psi",
  "\\Psi",
  "\\qquad",
  "\\quad",
  "\\rangle",
  "\\rbrace",
  "\\rbrack",
  "\\rceil",
  "\\Re",
  "\\ref{#}",
  "\\refeq{#}",
  "\\renewcommand{#}{#}",
  "\\renewenvironment{#}{#}{#}",
  "\\renewtagform{#}{#}{#}",
  "\\restriction",
  "\\rfloor",
  "\\rgroup",
  "\\rhd",
  "\\rho",
  "\\Rightarrow",
  "\\rightarrow",
  "\\rightarrowtail",
  "\\rightharpoondown",
  "\\rightharpoonup",
  "\\rightleftarrows",
  "\\rightleftharpoons",
  "\\rightrightarrows",
  "\\rightsquigarrow",
  "\\rightthreetimes",
  "\\risingdotseq",
  "\\rlap{#}",
  "\\rm",
  "\\rmoustache",
  "\\rparen",
  "\\Rrightarrow",
  "\\Rsh",
  "\\rtimes",
  "\\rvert",
  "\\rVert",
  "\\S",
  "\\scr",
  "\\scriptscriptstyle",
  "\\scriptsize",
  "\\scriptstyle",
  "\\searrow",
  "\\sec",
  "\\set{#}",
  "\\Set{#}",
  "\\setminus",
  "\\sf",
  "\\sharp",
  "\\shortmid",
  "\\shortparallel",
  "\\sideset{#}{#}{#}",
  "\\sigma",
  "\\Sigma",
  "\\sim",
  "\\simeq",
  "\\sin",
  "\\sinh",
  "\\skew{#}{#}{#}",
  "\\SkipLimits",
  "\\small",
  "\\smallfrown",
  "\\smallint",
  "\\smallsetminus",
  "\\smallsmile",
  "\\smash{#}",
  "\\smile",
  "\\space",
  "\\spadesuit",
  "\\sphericalangle",
  "\\splitdfrac{#}{#}",
  "\\splitfrac{#}{#}",
  "\\sqcap",
  "\\sqcup",
  "\\sqrt{#}",
  "\\sqsubset",
  "\\sqsubseteq",
  "\\sqsupset",
  "\\sqsupseteq",
  "\\square",
  "\\stackbin{#}{#}",
  "\\stackrel{#}{#}",
  "\\star",
  "\\strut",
  "\\style{#}{#}",
  "\\subset",
  "\\Subset",
  "\\subseteq",
  "\\subseteqq",
  "\\subsetneq",
  "\\subsetneqq",
  "\\substack{#}",
  "\\succ",
  "\\succapprox",
  "\\succcurlyeq",
  "\\succeq",
  "\\succnapprox",
  "\\succneqq",
  "\\succnsim",
  "\\succsim",
  "\\sum",
  "\\sum^{#}_{#}",
  "\\sup",
  "\\supset",
  "\\Supset",
  "\\supseteq",
  "\\supseteqq",
  "\\supsetneq",
  "\\supsetneqq",
  "\\surd",
  "\\swarrow",
  "\\symbb{#}",
  "\\symbf{#}",
  "\\symbfcal{#}",
  "\\symbffrak{#}",
  "\\symbfit{#}",
  "\\symbfscr{#}",
  "\\symbfsf{#}",
  "\\symbfsfit{#}",
  "\\symbfsfup{#}",
  "\\symbfup{#}",
  "\\symcal{#}",
  "\\symfrak{#}",
  "\\symit{#}",
  "\\symnormal{#}",
  "\\symrm{#}",
  "\\symscr{#}",
  "\\symsf{#}",
  "\\symsfit{#}",
  "\\symsfup{#}",
  "\\symtt{#}",
  "\\symup{#}",
  "\\tag{#}",
  "\\tan",
  "\\tanh",
  "\\tau",
  "\\tbinom{#}{#}",
  "\\TeX",
  "\\text{#}",
  "\\textacutedbl",
  "\\textasciiacute",
  "\\textasciibreve",
  "\\textasciicaron",
  "\\textasciicircum",
  "\\textasciidieresis",
  "\\textasciimacron",
  "\\textasciitilde",
  "\\textasteriskcentered",
  "\\textbackslash",
  "\\textbaht",
  "\\textbar",
  "\\textbardbl",
  "\\textbf{#}",
  "\\textbigcircle",
  "\\textblank",
  "\\textborn",
  "\\textbraceleft",
  "\\textbraceright",
  "\\textbrokenbar",
  "\\textbullet",
  "\\textcelsius",
  "\\textcent",
  "\\textcentoldstyle",
  "\\textcircledP",
  "\\textclap{#}",
  "\\textcolonmonetary",
  "\\textcolor{#}{#}",
  "\\textcompwordmark",
  "\\textcopyleft",
  "\\textcopyright",
  "\\textcurrency",
  "\\textdagger",
  "\\textdaggerdbl",
  "\\textdegree",
  "\\textdied",
  "\\textdiscount",
  "\\textdiv",
  "\\textdivorced",
  "\\textdollar",
  "\\textdollaroldstyle",
  "\\textdong",
  "\\textdownarrow",
  "\\texteightoldstyle",
  "\\textellipsis",
  "\\textemdash",
  "\\textendash",
  "\\textestimated",
  "\\texteuro",
  "\\textexclamdown",
  "\\textfiveoldstyle",
  "\\textflorin",
  "\\textfouroldstyle",
  "\\textfractionsolidus",
  "\\textgravedbl",
  "\\textgreater",
  "\\textguarani",
  "\\textinterrobang",
  "\\textinterrobangdown",
  "\\textit{#}",
  "\\textlangle",
  "\\textlbrackdbl",
  "\\textleftarrow",
  "\\textless",
  "\\textlira",
  "\\textllap{#}",
  "\\textlnot",
  "\\textlquill",
  "\\textmarried",
  "\\textmho",
  "\\textminus",
  "\\textmu",
  "\\textmusicalnote",
  "\\textnaira",
  "\\textnineoldstyle",
  "\\textnormal{#}",
  "\\textnumero",
  "\\textohm",
  "\\textonehalf",
  "\\textoneoldstyle",
  "\\textonequarter",
  "\\textonesuperior",
  "\\textopenbullet",
  "\\textordfeminine",
  "\\textordmasculine",
  "\\textparagraph",
  "\\textperiodcentered",
  "\\textpertenthousand",
  "\\textperthousand",
  "\\textpeso",
  "\\textpm",
  "\\textquestiondown",
  "\\textquotedblleft",
  "\\textquotedblright",
  "\\textquoteleft",
  "\\textquoteright",
  "\\textrangle",
  "\\textrbrackdbl",
  "\\textrecipe",
  "\\textreferencemark",
  "\\textregistered",
  "\\textrightarrow",
  "\\textrlap{#}",
  "\\textrm{#}",
  "\\textrquill",
  "\\textsection",
  "\\textservicemark",
  "\\textsevenoldstyle",
  "\\textsf{#}",
  "\\textsixoldstyle",
  "\\textsterling",
  "\\textstyle",
  "\\textsurd",
  "\\textthreeoldstyle",
  "\\textthreequarters",
  "\\textthreesuperior",
  "\\texttildelow",
  "\\texttimes",
  "\\texttip{#}{#}",
  "\\texttrademark",
  "\\texttt{#}",
  "\\texttwooldstyle",
  "\\texttwosuperior",
  "\\textunderscore",
  "\\textup{#}",
  "\\textuparrow",
  "\\textvisiblespace",
  "\\textwon",
  "\\textyen",
  "\\textzerooldstyle",
  "\\tfrac{#}{#}",
  "\\therefore",
  "\\theta",
  "\\Theta",
  "\\thickapprox",
  "\\thicksim",
  "\\thinspace",
  "\\tilde{#}",
  "\\times",
  "\\tiny",
  "\\Tiny",
  "\\to",
  "\\top",
  "\\triangle",
  "\\triangledown",
  "\\triangleleft",
  "\\trianglelefteq",
  "\\triangleq",
  "\\triangleright",
  "\\trianglerighteq",
  "\\tripledash",
  "\\tt",
  "\\twoheadleftarrow",
  "\\twoheadrightarrow",
  "\\ulcorner",
  "\\underbrace{#}",
  "\\underbracket{#}",
  "\\underleftarrow{#}",
  "\\underleftrightarrow{#}",
  "\\underline{#}",
  "\\underparen{#}",
  "\\underrightarrow{#}",
  "\\underset{#}{#}",
  "\\unicode{#}",
  "\\unlhd",
  "\\unrhd",
  "\\upalpha",
  "\\uparrow",
  "\\Uparrow",
  "\\upbeta",
  "\\upchi",
  "\\updelta",
  "\\Updelta",
  "\\updownarrow",
  "\\Updownarrow",
  "\\upepsilon",
  "\\upeta",
  "\\upgamma",
  "\\Upgamma",
  "\\upharpoonleft",
  "\\upharpoonright",
  "\\upiota",
  "\\upkappa",
  "\\uplambda",
  "\\Uplambda",
  "\\uplus",
  "\\upmu",
  "\\upnu",
  "\\upomega",
  "\\Upomega",
  "\\upomicron",
  "\\upphi",
  "\\Upphi",
  "\\uppi",
  "\\Uppi",
  "\\uppsi",
  "\\Uppsi",
  "\\uprho",
  "\\upsigma",
  "\\Upsigma",
  "\\upsilon",
  "\\Upsilon",
  "\\uptau",
  "\\uptheta",
  "\\Uptheta",
  "\\upuparrows",
  "\\upupsilon",
  "\\Upupsilon",
  "\\upvarepsilon",
  "\\upvarphi",
  "\\upvarpi",
  "\\upvarrho",
  "\\upvarsigma",
  "\\upvartheta",
  "\\upxi",
  "\\Upxi",
  "\\upzeta",
  "\\urcorner",
  "\\usetagform{#}",
  "\\varDelta",
  "\\varepsilon",
  "\\varGamma",
  "\\varinjlim",
  "\\varkappa",
  "\\varLambda",
  "\\varliminf",
  "\\varlimsup",
  "\\varnothing",
  "\\varOmega",
  "\\varphi",
  "\\varPhi",
  "\\varpi",
  "\\varPi",
  "\\varprojlim",
  "\\varpropto",
  "\\varPsi",
  "\\varrho",
  "\\varsigma",
  "\\varSigma",
  "\\varsubsetneq",
  "\\varsubsetneqq",
  "\\varsupsetneq",
  "\\varsupsetneqq",
  "\\vartheta",
  "\\varTheta",
  "\\vartriangle",
  "\\vartriangleleft",
  "\\vartriangleright",
  "\\varUpsilon",
  "\\varXi",
  "\\vcenter{#}",
  "\\vdash",
  "\\vDash",
  "\\Vdash",
  "\\vdots",
  "\\vec{#}",
  "\\vee",
  "\\veebar",
  "\\Vert",
  "\\vert",
  "\\vphantom{#}",
  "\\Vvdash",
  "\\wedge",
  "\\widehat{#}",
  "\\widetilde{#}",
  "\\wp",
  "\\wr",
  "\\xcancel{#}",
  "\\xhookleftarrow{#}",
  "\\xhookrightarrow{#}",
  "\\xi",
  "\\Xi",
  "\\xleftarrow{#}",
  "\\xLeftarrow{#}",
  "\\xleftharpoondown{#}",
  "\\xleftharpoonup{#}",
  "\\xleftrightarrow{#}",
  "\\xLeftrightarrow{#}",
  "\\xleftrightharpoons{#}",
  "\\xLeftrightharpoons{#}",
  "\\xlongequal{#}",
  "\\xmapsto{#}",
  "\\xmathstrut{#}",
  "\\xrightarrow{#}",
  "\\xRightarrow{#}",
  "\\xrightharpoondown{#}",
  "\\xrightharpoonup{#}",
  "\\xrightleftharpoons{#}",
  "\\xRightleftharpoons{#}",
  "\\xtofrom{#}",
  "\\xtwoheadleftarrow{#}",
  "\\xtwoheadrightarrow{#}",
  "\\yen",
  "\\zeta"
].sort((a, b) => getSuggestionDisplayName(a).length - getSuggestionDisplayName(b).length);

// src/settings.ts
var WordInsertionMode;
(function(WordInsertionMode2) {
  WordInsertionMode2["MATCH_CASE_REPLACE"] = "Match-Case & Replace";
  WordInsertionMode2["IGNORE_CASE_REPLACE"] = "Ignore-Case & Replace";
  WordInsertionMode2["IGNORE_CASE_APPEND"] = "Ignore-Case & Append";
})(WordInsertionMode || (WordInsertionMode = {}));
var InsertionKey;
(function(InsertionKey2) {
  InsertionKey2["ENTER"] = "Enter";
  InsertionKey2["TAB"] = "Tab";
})(InsertionKey || (InsertionKey = {}));
var DEFAULT_SETTINGS = {
  characterRegex: "a-zA-Z\xF6\xE4\xFC\xD6\xC4\xDC\xDF",
  maxLookBackDistance: 50,
  minWordLength: 2,
  minWordTriggerLength: 3,
  insertionKey: InsertionKey.ENTER,
  wordInsertionMode: WordInsertionMode.IGNORE_CASE_REPLACE,
  latexProviderEnabled: true,
  fileScannerProviderEnabled: true,
  fileScannerScanCurrent: true,
  wordListProviderEnabled: true,
  frontMatterProviderEnabled: true,
  frontMatterTagAppendSuffix: true
};

// src/provider/dictionary_provider.ts
var DictionaryProvider = class {
  getSuggestions(context, settings) {
    var _a, _b, _c;
    if (!this.isEnabled(settings) || !context.query || context.query.length < settings.minWordTriggerLength)
      return [];
    const ignoreCase = settings.wordInsertionMode != WordInsertionMode.MATCH_CASE_REPLACE;
    const query = ignoreCase ? context.query.toLowerCase() : context.query;
    const firstChar = query.charAt(0);
    const list = ignoreCase ? [(_a = this.wordMap.get(firstChar)) != null ? _a : [], (_b = this.wordMap.get(firstChar.toUpperCase())) != null ? _b : []] : [(_c = this.wordMap.get(firstChar)) != null ? _c : []];
    if (!list || list.length < 1)
      return [];
    const result = new Set();
    for (let el of list) {
      filterMapIntoSet(result, el, (s) => {
        const match = ignoreCase ? s.toLowerCase() : s;
        return match.startsWith(query);
      }, settings.wordInsertionMode === WordInsertionMode.IGNORE_CASE_APPEND ? (s) => context.query + s.substring(query.length, s.length) : (s) => s);
    }
    return [...result].sort((a, b) => a.length - b.length);
  }
};
function filterMapIntoSet(set, iterable, predicate, map) {
  for (let val of iterable) {
    if (!predicate(val))
      continue;
    set.add(map(val));
  }
}

// src/provider/word_list_provider.ts
var BASE_FOLDER_PATH = ".obsidian/plugins/obsidian-completr/wordLists";
var WordListSuggestionProvider = class extends DictionaryProvider {
  constructor() {
    super(...arguments);
    this.wordMap = new Map();
  }
  isEnabled(settings) {
    return settings.wordListProviderEnabled;
  }
  loadFromFiles(vault, settings) {
    return __async(this, null, function* () {
      this.wordMap.clear();
      const fileNames = yield this.getRelativeFilePaths(vault);
      for (let i = fileNames.length - 1; i >= 0; i--) {
        const fileName = fileNames[i];
        let data;
        try {
          data = yield vault.adapter.read(fileName);
        } catch (e) {
          console.log("Completr: Unable to read " + fileName);
          continue;
        }
        const lines = data.split("\n");
        for (let line of lines) {
          if (line === "" || line.length < settings.minWordLength)
            continue;
          let list = this.wordMap.get(line.charAt(0));
          if (!list) {
            list = [];
            this.wordMap.set(line.charAt(0), list);
          }
          list.push(line.trim());
        }
      }
      let count = 0;
      for (let entry of this.wordMap.entries()) {
        entry[1] = entry[1].sort((a, b) => a.length - b.length);
        count += entry[1].length;
      }
      return count;
    });
  }
  deleteWordList(vault, path) {
    return __async(this, null, function* () {
      yield vault.adapter.remove(path);
    });
  }
  importWordList(vault, name, text) {
    return __async(this, null, function* () {
      const path = BASE_FOLDER_PATH + "/" + name;
      if (yield vault.adapter.exists(path))
        return false;
      yield vault.adapter.write(path, text);
      return true;
    });
  }
  getRelativeFilePaths(vault) {
    return __async(this, null, function* () {
      if (!(yield vault.adapter.exists(BASE_FOLDER_PATH)))
        yield vault.adapter.mkdir(BASE_FOLDER_PATH);
      return (yield vault.adapter.list(BASE_FOLDER_PATH)).files;
    });
  }
};
var WordList = new WordListSuggestionProvider();

// src/provider/scanner_provider.ts
var SCANNED_WORDS_PATH = ".obsidian/plugins/obsidian-completr/scanned_words.txt";
var ScannerSuggestionProvider = class extends DictionaryProvider {
  constructor() {
    super(...arguments);
    this.wordMap = new Map();
  }
  isEnabled(settings) {
    return settings.fileScannerProviderEnabled;
  }
  scanFiles(settings, files) {
    return __async(this, null, function* () {
      for (let file of files) {
        yield this.scanFile(settings, file, false);
      }
      yield this.saveData(files[0].vault);
    });
  }
  scanFile(settings, file, saveImmediately) {
    return __async(this, null, function* () {
      const contents = yield file.vault.cachedRead(file);
      const regex = new RegExp("\\$+.*?\\$+|`+.*?`+|\\[+.*?\\]+|([" + settings.characterRegex + "]+)", "gsu");
      for (let match of contents.matchAll(regex)) {
        const groupValue = match[1];
        if (!groupValue || groupValue.length < settings.minWordLength)
          continue;
        this.addWord(groupValue);
      }
      if (saveImmediately)
        yield this.saveData(file.vault);
    });
  }
  saveData(vault) {
    return __async(this, null, function* () {
      let output = [];
      for (let entry of this.wordMap.entries()) {
        output = [...output, ...entry[1]];
      }
      yield vault.adapter.write(SCANNED_WORDS_PATH, output.join("\n"));
    });
  }
  loadData(vault) {
    return __async(this, null, function* () {
      if (!(yield vault.adapter.exists(SCANNED_WORDS_PATH)))
        return;
      const contents = (yield vault.adapter.read(SCANNED_WORDS_PATH)).split("\n");
      for (let word of contents) {
        this.addWord(word);
      }
    });
  }
  deleteAllWords(vault) {
    return __async(this, null, function* () {
      this.wordMap.clear();
      yield this.saveData(vault);
    });
  }
  addWord(word) {
    if (!word)
      return;
    let list = this.wordMap.get(word.charAt(0));
    if (!list) {
      list = new Set();
      this.wordMap.set(word.charAt(0), list);
    }
    list.add(word);
  }
};
var FileScanner = new ScannerSuggestionProvider();

// src/popup.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/provider/front_matter_provider.ts
var import_obsidian = __toModule(require("obsidian"));
var BASE_SUGGESTION = {
  displayName: "front-matter",
  replacement: "---\n~\n---",
  overrideStart: { line: 0, ch: 0 }
};
var PUBLISH_SUGGESTION = {
  displayName: "publish: #",
  replacement: "publish: ~"
};
function findTagCompletionType(keyInfo, currentLineIndex, currentLine, editor) {
  const { key, isList } = keyInfo;
  if (currentLine.startsWith(key + ": "))
    return "inline";
  if (!currentLine.startsWith("- ") || !isList)
    return "none";
  let foundListStart = false;
  for (let i = currentLineIndex - 1; i >= 1; i--) {
    let line = editor.getLine(i).trim();
    if (line.endsWith(":")) {
      foundListStart = line.startsWith(key + ":");
      break;
    }
  }
  return foundListStart ? "multiline" : "none";
}
var YAMLKeyCache = class {
  constructor() {
    this.listKeys = [];
    this.keyMap = new Map();
  }
  addEntry(key, value) {
    let values = this.keyMap.get(key);
    if (!values) {
      values = new Set();
      this.keyMap.set(key, values);
    }
    values.add(value);
  }
  addEntries(key, values) {
    let set = this.keyMap.get(key);
    if (!set) {
      set = new Set();
      this.keyMap.set(key, set);
    }
    for (let value of values) {
      if (!value)
        continue;
      set.add(value);
    }
    this.listKeys.push(key);
  }
  isListKey(key) {
    return this.listKeys.contains(key);
  }
  getCompletions() {
    return [...this.keyMap.entries()].map(([e, v]) => ({ key: e, isList: this.isListKey(e), completions: v }));
  }
};
var FrontMatterSuggestionProvider = class {
  constructor() {
    this.blocksAllOtherProviders = true;
    this.fileSuggestionCache = new Map();
    this.onCacheChange = (file, data, cache) => {
      this.addKeyCompletionsFromFile(file, cache);
    };
  }
  getSuggestions(context, settings) {
    var _a;
    if (!settings.frontMatterProviderEnabled)
      return [];
    const firstLine = context.editor.getLine(0);
    const isInFrontMatter = isInFrontMatterBlock(context.editor, context.start);
    if (!isInFrontMatter && context.start.line === 0 && (firstLine === "" || "front-matter".startsWith(firstLine))) {
      return [BASE_SUGGESTION];
    } else if (!isInFrontMatter) {
      return [];
    }
    const lowerCaseQuery = context.query.toLowerCase();
    if (context.start.ch === 0) {
      const suggestions = this.getPossibleCompletions().flatMap((i) => {
        if (!i.isList) {
          return [{
            displayName: i.key + ": #",
            replacement: i.key + ": ~"
          }];
        }
        return [
          {
            displayName: i.key + ": [#]",
            replacement: i.key + ": [~]"
          },
          {
            displayName: i.key + ": \\...",
            replacement: i.key + ":\n- ~"
          }
        ];
      });
      suggestions.push(PUBLISH_SUGGESTION);
      return suggestions.filter((snippet) => {
        const displayName = getSuggestionDisplayName(snippet);
        const key2 = displayName.substring(0, displayName.indexOf(":"));
        return key2.startsWith(lowerCaseQuery);
      });
    }
    const currentLine = context.editor.getLine(context.start.line);
    if (currentLine.startsWith("publish:")) {
      return FrontMatterSuggestionProvider.getPublishSuggestions(lowerCaseQuery);
    }
    const { key, type } = (_a = this.getPossibleCompletions().map((possibleKey) => ({
      key: possibleKey,
      type: findTagCompletionType(possibleKey, context.start.line, currentLine, context.editor)
    })).filter(({ type: type2 }) => type2 !== "none").shift()) != null ? _a : {};
    if (!key)
      return [];
    const { query } = matchWordBackwards(context.editor, context.end, (char) => new RegExp("[" + settings.characterRegex + "/\\-_]", "u").test(char), settings.maxLookBackDistance);
    return [...key.completions].filter((tag) => tag.startsWith(query)).map((tag) => ({
      displayName: tag,
      replacement: tag + (settings.frontMatterTagAppendSuffix && key.isList ? type === "inline" ? ", " : "\n- " : ""),
      overrideStart: __spreadProps(__spreadValues({}, context.end), { ch: context.end.ch - query.length })
    })).sort((a, b) => a.displayName.length - b.displayName.length);
  }
  loadYAMLKeyCompletions(cache, files) {
    for (let file of files) {
      this.addKeyCompletionsFromFile(file, cache.getFileCache(file));
    }
  }
  addKeyCompletionsFromFile(file, cache) {
    if (!file || !cache || !cache.frontmatter) {
      return;
    }
    const keyCache = new YAMLKeyCache();
    this.fileSuggestionCache.set(file.path, keyCache);
    for (let key of Object.keys(cache.frontmatter)) {
      if (key === "position" || key === "publish" || key === "tags")
        continue;
      let prop = cache.frontmatter[key];
      if (!prop)
        continue;
      if (Array.isArray(prop)) {
        keyCache.addEntries(key, prop);
      } else {
        keyCache.addEntry(key, prop);
      }
    }
    const tags = (0, import_obsidian.getAllTags)(cache);
    if (tags && tags.length > 0)
      keyCache.addEntries("tags", tags.map((t) => t.substring(1)));
  }
  getPossibleCompletions() {
    const listKeys = new Set();
    const allKeys = new Map();
    for (let cache of this.fileSuggestionCache.values()) {
      for (let keyInfo of cache.getCompletions()) {
        let completions = allKeys.get(keyInfo.key);
        if (!completions) {
          completions = new Set();
          allKeys.set(keyInfo.key, completions);
        }
        keyInfo.completions.forEach((c) => completions.add(c));
        if (keyInfo.isList)
          listKeys.add(keyInfo.key);
      }
    }
    return [...allKeys.entries()].map(([k, completions]) => ({
      key: k,
      isList: listKeys.has(k),
      completions
    }));
  }
  static getPublishSuggestions(lowerCaseQuery) {
    const possibilities = ["true", "false"];
    const partialMatches = possibilities.filter((val) => val.startsWith(lowerCaseQuery) && val !== lowerCaseQuery);
    if (partialMatches.length > 0)
      return partialMatches;
    else if (lowerCaseQuery === "true" || lowerCaseQuery === "false")
      return lowerCaseQuery === "true" ? possibilities.reverse() : possibilities;
    return [];
  }
};
var FrontMatter = new FrontMatterSuggestionProvider();

// src/popup.ts
var PROVIDERS = [FrontMatter, Latex, FileScanner, WordList];
var SuggestionPopup = class extends import_obsidian2.EditorSuggest {
  constructor(app, settings, snippetManager) {
    super(app);
    var _a;
    this.disableSnippets = (_a = app.vault.config) == null ? void 0 : _a.legacyEditor;
    this.settings = settings;
    this.snippetManager = snippetManager;
    let self = this;
    self.scope.unregister(self.scope.keys.find((k) => k.key === "Enter"));
    this.setInsertionKey(settings.insertionKey);
  }
  getSuggestions(context) {
    let suggestions = [];
    for (let provider of PROVIDERS) {
      suggestions = [...suggestions, ...provider.getSuggestions(__spreadProps(__spreadValues({}, context), {
        separatorChar: this.separatorChar
      }), this.settings)];
      if (provider.blocksAllOtherProviders && suggestions.length > 0) {
        suggestions.forEach((suggestion) => {
          if (typeof suggestion === "string" || !suggestion.overrideStart)
            return;
          this.context.start = suggestion.overrideStart;
        });
        break;
      }
    }
    return suggestions;
  }
  onTrigger(cursor, editor, file) {
    if (this.justClosed) {
      this.justClosed = false;
      return null;
    }
    let {
      query,
      separatorChar
    } = matchWordBackwards(editor, cursor, (char) => this.getCharacterRegex().test(char), this.settings.maxLookBackDistance);
    this.separatorChar = separatorChar;
    return {
      start: __spreadProps(__spreadValues({}, cursor), {
        ch: cursor.ch - query.length
      }),
      end: cursor,
      query
    };
  }
  renderSuggestion(value, el) {
    el.addClass("completr-suggestion-item");
    el.setText(getSuggestionDisplayName(value));
  }
  selectSuggestion(value, evt) {
    const replacement = getSuggestionReplacement(value);
    const start = typeof value !== "string" && value.overrideStart ? value.overrideStart : this.context.start;
    this.context.editor.replaceRange(replacement, start, this.context.end);
    if (replacement.contains("#") || replacement.contains("~")) {
      if (!this.disableSnippets) {
        this.snippetManager.handleSnippet(replacement, start, this.context.editor);
      } else {
        console.log("Completr: Please enable Live Preview mode to use snippets");
      }
    } else {
      this.context.editor.setCursor(__spreadProps(__spreadValues({}, start), { ch: start.ch + replacement.length }));
    }
    this.close();
    this.justClosed = true;
  }
  preventNextTrigger() {
    this.justClosed = true;
  }
  setInsertionKey(key) {
    let self = this;
    this.disableInsertionKey();
    this.insertionKeybindRegistration = self.scope.register([], key, (event) => {
      self.suggestions.useSelectedItem(event);
      return false;
    });
  }
  disableInsertionKey() {
    let self = this;
    if (this.insertionKeybindRegistration)
      self.scope.unregister(this.insertionKeybindRegistration);
  }
  getCharacterRegex() {
    if (this.characterRegex !== this.settings.characterRegex)
      this.compiledCharacterRegex = new RegExp("[" + this.settings.characterRegex + "]", "u");
    return this.compiledCharacterRegex;
  }
};

// src/settings_tab.ts
var import_obsidian3 = __toModule(require("obsidian"));
var CompletrSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Word character regex").setDesc("A regular expression which matches a character of a word. Used by during completion to find the word to the left of the cursor and used by the file scanner to find valid words.").addText((text) => text.setValue(this.plugin.settings.characterRegex).onChange((val) => __async(this, null, function* () {
      try {
        new RegExp("[" + val + "]+").test("");
        text.inputEl.removeClass("completr-settings-error");
        this.plugin.settings.characterRegex = val;
        yield this.plugin.saveSettings();
      } catch (e) {
        text.inputEl.addClass("completr-settings-error");
      }
    })));
    new import_obsidian3.Setting(containerEl).setName("Minimum word length").setDesc("The minimum length a word has to be, to count as a valid suggestion. This value is used by the file scanner and word list provider.").addText((text) => {
      text.inputEl.type = "number";
      text.setValue(this.plugin.settings.minWordLength + "").onChange((val) => __async(this, null, function* () {
        if (!val || val.length < 1)
          return;
        this.plugin.settings.minWordLength = parseInt(val);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Minimum word trigger length").setDesc("The minimum length a word has to be, to trigger suggestions. This value is ignored by the LaTeX provider.").addText((text) => {
      text.inputEl.type = "number";
      text.setValue(this.plugin.settings.minWordTriggerLength + "").onChange((val) => __async(this, null, function* () {
        if (!val || val.length < 1)
          return;
        this.plugin.settings.minWordTriggerLength = parseInt(val);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Insertion key").setDesc("The key you want to use to insert suggestions while the popup is open.").addDropdown((dropdown) => {
      dropdown.addOption(InsertionKey.ENTER, InsertionKey.ENTER).addOption(InsertionKey.TAB, InsertionKey.TAB).setValue(this.plugin.settings.insertionKey).onChange((val) => __async(this, null, function* () {
        this.plugin.settings.insertionKey = val;
        this.plugin.suggestionPopup.setInsertionKey(val);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Word insertion mode").setDesc("The insertion mode that is used. Ignore-case would suggest 'Hello' if the typed text is 'hello', match-case would not. Append would complete 'Hell' with 'Hello' while replace would complete it with 'hello' instead (if only 'hello' was a known word).").addDropdown((dropdown) => dropdown.addOption(WordInsertionMode.IGNORE_CASE_REPLACE, WordInsertionMode.IGNORE_CASE_REPLACE).addOption(WordInsertionMode.IGNORE_CASE_APPEND, WordInsertionMode.IGNORE_CASE_APPEND).addOption(WordInsertionMode.MATCH_CASE_REPLACE, WordInsertionMode.MATCH_CASE_REPLACE).setValue(this.plugin.settings.wordInsertionMode).onChange((val) => __async(this, null, function* () {
      this.plugin.settings.wordInsertionMode = val;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Latex provider").setHeading();
    this.createEnabledSetting("latexProviderEnabled", "Whether or not the latex provider is enabled", containerEl);
    new import_obsidian3.Setting(containerEl).setName("Front matter provider").addExtraButton((button) => button.setIcon("link").setTooltip("Obsidian Front-Matter wiki").onClick(() => window.open("https://help.obsidian.md/Advanced+topics/YAML+front+matter"))).setHeading();
    this.createEnabledSetting("frontMatterProviderEnabled", "Whether the front matter provider is enabled", containerEl);
    new import_obsidian3.Setting(containerEl).setName("Add suffix to tag completion").setDesc("Whether each completed tag should be suffixed with a comma or a newline (when typing in a multi-line list). Allows faster insertion of multiple tags.").addToggle((toggle) => toggle.setValue(this.plugin.settings.frontMatterTagAppendSuffix).onChange((val) => __async(this, null, function* () {
      this.plugin.settings.frontMatterTagAppendSuffix = val;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("File scanner provider").setHeading().addExtraButton((button) => button.setIcon("search").setTooltip("Immediately scan all .md files currently in your vault.").onClick(() => {
      new ConfirmationModal(this.plugin.app, "Start scanning?", "Depending on the size of your vault and computer, this may take a while.", (button2) => button2.setButtonText("Scan").setCta(), () => __async(this, null, function* () {
        yield FileScanner.scanFiles(this.plugin.settings, this.plugin.app.vault.getMarkdownFiles());
      })).open();
    })).addExtraButton((button) => button.setIcon("trash").setTooltip("Delete all known words.").onClick(() => __async(this, null, function* () {
      new ConfirmationModal(this.plugin.app, "Delete all known words?", "This will delete all words that have been scanned. No suggestions from this provider will show up anymore until new files are scanned.", (button2) => button2.setButtonText("Delete").setWarning(), () => __async(this, null, function* () {
        yield FileScanner.deleteAllWords(this.plugin.app.vault);
      })).open();
    })));
    this.createEnabledSetting("fileScannerProviderEnabled", "Whether or not the file scanner provider is enabled.", containerEl);
    new import_obsidian3.Setting(containerEl).setName("Scan active file").setDesc("If this setting is enabled, the currently opened file will be scanned to find new words.").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileScannerScanCurrent).onChange((val) => __async(this, null, function* () {
      this.plugin.settings.fileScannerScanCurrent = val;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Word list provider").setHeading();
    this.createEnabledSetting("wordListProviderEnabled", "Whether or not the word list provider is enabled", containerEl);
    const fileInput = createEl("input", {
      attr: {
        type: "file"
      }
    });
    fileInput.onchange = () => __async(this, null, function* () {
      const files = fileInput.files;
      if (files.length < 1)
        return;
      let changed = false;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const text = yield file.text();
        const success = yield WordList.importWordList(this.app.vault, file.name, text);
        changed || (changed = success);
        if (!success)
          new import_obsidian3.Notice("Unable to import " + file.name + " because it already exists!");
      }
      if (!changed)
        return;
      yield this.reloadWords();
      this.display();
    });
    new import_obsidian3.Setting(containerEl).setName("Word list files").setDesc("A list of files which contain words to be used as suggestions. Each word should be on its own line.").addExtraButton((button) => button.setIcon("switch").setTooltip("Reload").onClick(() => __async(this, null, function* () {
      yield this.reloadWords();
      this.display();
    }))).addButton((button) => {
      button.buttonEl.appendChild(fileInput);
      button.setButtonText("+").setCta().onClick(() => fileInput.click());
    });
    const wordListDiv = containerEl.createDiv();
    WordList.getRelativeFilePaths(this.app.vault).then((names) => {
      for (const name of names) {
        new import_obsidian3.Setting(wordListDiv).setName(name).addExtraButton((button) => button.setIcon("trash").setTooltip("Remove").onClick(() => __async(this, null, function* () {
          new ConfirmationModal(this.app, "Delete " + name + "?", "The file will be removed and the words inside of it won't show up as suggestions anymore.", (button2) => button2.setButtonText("Delete").setWarning(), () => __async(this, null, function* () {
            yield WordList.deleteWordList(this.app.vault, name);
            yield this.reloadWords();
            this.display();
          })).open();
        }))).settingEl.addClass("completr-settings-list-item");
      }
    });
  }
  reloadWords() {
    return __async(this, null, function* () {
      if (this.isReloadingWords)
        return;
      this.isReloadingWords = true;
      const count = yield WordList.loadFromFiles(this.app.vault, this.plugin.settings);
      this.isReloadingWords = false;
      new import_obsidian3.Notice(`Loaded ${count} words`);
    });
  }
  createEnabledSetting(propertyName, desc, container) {
    new import_obsidian3.Setting(container).setName("Enabled").setDesc(desc).addToggle((toggle) => toggle.setValue(this.plugin.settings[propertyName]).onChange((val) => __async(this, null, function* () {
      this.plugin.settings[propertyName] = val;
      yield this.plugin.saveSettings();
    })));
  }
};
var ConfirmationModal = class extends import_obsidian3.Modal {
  constructor(app, title, body, buttonCallback, clickCallback) {
    super(app);
    this.titleEl.setText(title);
    this.contentEl.setText(body);
    new import_obsidian3.Setting(this.modalEl).addButton((button) => {
      buttonCallback(button);
      button.onClick(() => __async(this, null, function* () {
        yield clickCallback();
        this.close();
      }));
    }).addButton((button) => button.setButtonText("Cancel").onClick(() => this.close())).settingEl.addClass("completr-settings-no-border");
  }
};

// src/main.ts
var import_view3 = __toModule(require("@codemirror/view"));
var import_state2 = __toModule(require("@codemirror/state"));
var CompletrPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.onFileOpened = (file) => {
      if (!this.settings.fileScannerScanCurrent || !file)
        return;
      FileScanner.scanFile(this.settings, file, true);
    };
    this.handleKeydown = (event, cm) => {
      if (!Object.values(InsertionKey).contains(event.key))
        return;
      const view = cm.state.field(import_obsidian4.editorViewField, false);
      if (!view)
        return;
      const editor = view.editor;
      const placeholder = this.snippetManager.placeholderAtPos(editor.getCursor());
      const isPopupByPassKey = event.key != this.settings.insertionKey || event.shiftKey;
      if (this._suggestionPopup.isOpen && isPopupByPassKey) {
        this._suggestionPopup.close();
        if (event.key === InsertionKey.ENTER && event.key === this.settings.insertionKey)
          Object.defineProperty(event, "shiftKey", { value: false });
      }
      if (!placeholder)
        return;
      const placeholderEnd = posFromIndex(editorToCodeMirrorState(placeholder.editor).doc, placeholder.marker.to);
      event.preventDefault();
      if (!this.snippetManager.consumeAndGotoNextMarker(editor)) {
        editor.setSelections([{
          anchor: __spreadProps(__spreadValues({}, placeholderEnd), {
            ch: Math.min(editor.getLine(placeholderEnd.line).length, placeholderEnd.ch + 1)
          })
        }]);
      }
    };
  }
  onload() {
    return __async(this, null, function* () {
      var _a;
      yield this.loadSettings();
      this.snippetManager = new SnippetManager();
      this._suggestionPopup = new SuggestionPopup(this.app, this.settings, this.snippetManager);
      this.registerEditorSuggest(this._suggestionPopup);
      this.registerEvent(this.app.workspace.on("file-open", this.onFileOpened, this));
      this.registerEvent(this.app.metadataCache.on("changed", FrontMatter.onCacheChange, FrontMatter));
      this.app.workspace.onLayoutReady(() => FrontMatter.loadYAMLKeyCompletions(this.app.metadataCache, this.app.vault.getMarkdownFiles()));
      this.registerEditorExtension(markerStateField);
      this.registerEditorExtension(import_view3.EditorView.updateListener.of(new CursorActivityListener(this.snippetManager, this._suggestionPopup).listener));
      this.registerEditorExtension(import_state2.Prec.highest(import_view3.EditorView.domEventHandlers({
        "keydown": this.handleKeydown
      })));
      this.addSettingTab(new CompletrSettingsTab(this.app, this));
      this.addCommand({
        id: "completr-open-suggestion-popup",
        name: "Open suggestion popup",
        hotkeys: [
          {
            key: " ",
            modifiers: ["Mod"]
          }
        ],
        editorCallback: (editor) => {
          this._suggestionPopup.trigger(editor, this.app.workspace.getActiveFile(), true);
        }
      });
      if ((_a = this.app.vault.config) == null ? void 0 : _a.legacyEditor) {
        console.log("Completr: Without Live Preview enabled, most features of Completr will not work properly!");
      }
    });
  }
  onunload() {
    return __async(this, null, function* () {
      this.snippetManager.onunload();
      yield FileScanner.saveData(this.app.vault);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      WordList.loadFromFiles(this.app.vault, this.settings);
      FileScanner.loadData(this.app.vault);
    });
  }
  get suggestionPopup() {
    return this._suggestionPopup;
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var CursorActivityListener = class {
  constructor(snippetManager, suggestionPopup) {
    this.cursorTriggeredByChange = false;
    this.lastCursorLine = -1;
    this.listener = (update) => {
      if (update.docChanged) {
        this.handleDocChange();
      }
      if (update.selectionSet) {
        this.handleCursorActivity(posFromIndex(update.state.doc, update.state.selection.main.head));
      }
    };
    this.handleDocChange = () => {
      this.cursorTriggeredByChange = true;
    };
    this.handleCursorActivity = (cursor) => {
      if (this.lastCursorLine == cursor.line + 1)
        this.suggestionPopup.preventNextTrigger();
      this.lastCursorLine = cursor.line;
      if (!this.snippetManager.placeholderAtPos(cursor)) {
        this.snippetManager.clearAllPlaceholders();
      }
      if (this.cursorTriggeredByChange) {
        this.cursorTriggeredByChange = false;
        return;
      }
      this.suggestionPopup.close();
    };
    this.snippetManager = snippetManager;
    this.suggestionPopup = suggestionPopup;
  }
};
